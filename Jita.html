<!DOCTYPE html>
<html>
<head>
    <title>Pixel Miner Deluxe - Jita (DIAGNOSTIC)</title>
    <meta charset="UTF-8">
    <style>
        /* Styles remain the same */
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: black; color: white; font-family: 'Consolas', 'Courier New', monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; padding: 5px; background-color: rgba(0, 0, 0, 0.6); border: 1px solid #555; font-size: 14px; line-height: 1.4; pointer-events: none; z-index: 10; width: 280px; }
        #plexBarContainer { margin-top: 5px; padding-top: 5px; border-top: 1px solid #555; }
        #plexBar { width: 100%; height: 15px; background-color: #440000; border: 1px solid #880000; box-sizing: border-box; }
        #plexBarFill { width: 100%; height: 100%; background-color: #00FF00; transition: width 0.5s ease-out; }
        #plexBarLabel { font-size: 11px; color: #AAA; margin-bottom: 2px; }
        #plexBarContainer.warning #plexBarFill { background-color: #FFA500; }
        #plexBarContainer.critical #plexBarFill { background-color: #FF0000; animation: pulseRed 1s infinite; }
        @keyframes pulseRed { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        #message { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 10px; background-color: rgba(0, 50, 100, 0.8); border: 1px solid cyan; color: white; font-size: 16px; display: none; text-align: center; pointer-events: none; z-index: 10; max-width: 80%; }
        #message.local-chat { background-color: rgba(30, 30, 30, 0.85); border: 1px solid #888; text-align: left; font-style: italic; }
        #ticker { position: absolute; bottom: 10px; right: 10px; width: 300px; max-height: 100px; padding: 5px; background-color: rgba(10, 10, 10, 0.7); border: 1px solid #444; font-size: 11px; line-height: 1.3; color: #BBB; overflow: hidden; pointer-events: none; z-index: 5; }
        #ticker p { margin: 0 0 2px 0; padding: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #ticker-title { font-weight: bold; color: #DDD; margin-bottom: 4px; border-bottom: 1px solid #555; padding-bottom: 2px; }
        #gameOverOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: #FF4444; font-size: 24px; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 100; cursor: pointer; }
        #gameOverOverlay p { margin: 10px 0; }
        #gameOverOverlay small { font-size: 16px; color: #AAA; margin-top: 20px; }
        body.tidi-active::after { content: ''; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(120, 50, 150, 0.15); pointer-events: none; z-index: 90; opacity: 1; transition: opacity 0.5s ease-in-out; }
        #blackMarketButton { display: none; background-color: #550000; color: #FFAAAA; border: 1px solid #FF0000; padding: 5px 10px; margin-top: 10px; cursor: pointer; text-align: center; font-weight: bold; pointer-events: auto; }
        #blackMarketButton:hover { background-color: #880000; }
        #activeItemDisplay { margin-top: 5px; padding-top: 5px; border-top: 1px solid #555; font-size: 12px; color: #00FF00; min-height: 1.2em; /* Ensure space even when empty */ }
        #haxIndicator { position: absolute; bottom: 15px; right: 320px; /* Near ticker */ font-size: 18px; color: rgba(0, 255, 0, 0.7); display: none; opacity: 0; transition: opacity 0.3s ease-out; pointer-events: none; z-index: 6; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5); }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>ISK: <span id="isk">0</span></div>
        <div>Cargo Hold: <span id="cargo">0</span> / <span id="maxCargo">100</span></div>
        <div>Intel Logs: <span id="intelLogs">0</span></div>
        <div>Controls: [W] Thrust | [A/D] Turn | [M] Mine | [L] Local | [P] Buy PLEX (Docked)</div>
        <div>Objective: Mine Veldspar, Stay PLEXed, Don't get repo'd!</div>
        <div id="plexBarContainer">
            <div id="plexBarLabel">Capsuleer License Time:</div>
            <div id="plexBar"><div id="plexBarFill"></div></div>
        </div>
        <div id="blackMarketButton">Enter Black Market (Jita 4-4)</div>
        <div id="activeItemDisplay">Ship Systems: Nominal</div>
    </div>
    <div id="message"></div>
    <div id="ticker"><div id="ticker-title">Recent Transmissions:</div></div>
    <div id="gameOverOverlay">
        <p>!!! CONNECTION LOST !!!</p>
        <p>Capsule Subscription Expired.</p>
        <p>Vessel Impounded by CONCORD Authority.</p>
        <p>Final ISK Balance: <span id="finalIsk">0</span></p>
        <small>Click or Press Enter to Reactivate Clone Facility</small>
    </div>
    <div id="haxIndicator">▲</div>

    <script>
        console.log("DIAGNOSTIC: Script execution started.");

        // --- Get references ---
        const canvas = document.getElementById('gameCanvas');
        // *** DIAGNOSTIC: Check canvas existence ***
        if (!canvas) {
            console.error("DIAGNOSTIC: CRITICAL - Could not find canvas element with ID 'gameCanvas'");
            alert("DIAGNOSTIC Error: Canvas element not found! Check HTML ID.");
        }
        const ctx = canvas ? canvas.getContext('2d') : null;
        // *** DIAGNOSTIC: Check context existence ***
         if (!ctx) {
            console.error("DIAGNOSTIC: CRITICAL - Could not get 2D context for canvas");
             if(canvas) alert("DIAGNOSTIC Error: Failed to get 2D context! Browser might be unsupported.");
        } else {
            console.log("DIAGNOSTIC: Canvas and context obtained successfully.");
        }

        const iskEl = document.getElementById('isk'); const cargoEl = document.getElementById('cargo');
        const maxCargoEl = document.getElementById('maxCargo'); const messageEl = document.getElementById('message');
        const tickerEl = document.getElementById('ticker'); const plexBarFillEl = document.getElementById('plexBarFill');
        const plexBarContainerEl = document.getElementById('plexBarContainer');
        const gameOverOverlayEl = document.getElementById('gameOverOverlay'); const finalIskEl = document.getElementById('finalIsk');
        const blackMarketButtonEl = document.getElementById('blackMarketButton');
        const activeItemDisplayEl = document.getElementById('activeItemDisplay');
        const intelLogsEl = document.getElementById('intelLogs');
        const haxIndicatorEl = document.getElementById('haxIndicator');

        // --- Base Game Config Values (used for reset in applyItemEffects) ---
        const BASE_PLAYER_THRUST_POWER = 200;
        const BASE_PLAYER_TURN_RATE = Math.PI * 1.8;
        const BASE_PLAYER_MAX_CARGO = 100;
        const BASE_MINING_RATE = 25;
        const BASE_MINING_RANGE = 70;

        // --- Game Config & Constants ---
        const SCREEN_WIDTH = window.innerWidth; const SCREEN_HEIGHT = window.innerHeight;
        // *** DIAGNOSTIC: Set canvas size ***
        if (canvas) {
             canvas.width = SCREEN_WIDTH; canvas.height = SCREEN_HEIGHT;
             console.log(`DIAGNOSTIC: Canvas size set to ${SCREEN_WIDTH}x${SCREEN_HEIGHT}`);
        }
        if (ctx) {
            ctx.imageSmoothingEnabled = false;
        }

        // Colors
        const PLAYER_COLORS = { main: '#FFFFFF', trim: '#CCCCCC', cockpit: '#00FFFF', thrust: '#FFA500' };
        const STATION_COLORS = { main: '#0000FF', trim: '#00FFFF', lights_off: '#FFFF00', lights_on: '#FFFFFF' };
        const ASTEROID_COLORS = { main: '#8B4513', dark: '#654321', light: '#A0522D' };
        const MINING_BEAM_COLOR_START = 'rgba(255, 0, 0, 0.9)'; const MINING_BEAM_COLOR_END = 'rgba(255, 100, 100, 0.5)';
        const PARTICLE_COLORS = ['#FFA500', '#FF4500', '#FF6347', '#FFD700'];
        const NPC_FRIGATE_COLORS = { main: '#FF0000', trim: '#AA0000', cockpit: '#FFAAAA' };
        const NPC_HAULER_COLORS = { main: '#00FF00', trim: '#00AA00', cockpit: '#AAFFAA' };
        const CONCORD_COLORS = { main: '#0055BB', trim: '#FFFFFF', cockpit: '#00FFFF', thrust: '#EEEEFF' };
        const CYNO_COLORS = { center: 'rgba(200, 220, 255, 0.9)', middle: 'rgba(100, 150, 255, 0.6)', edge: 'rgba(50, 80, 200, 0.2)', lightning: 'rgba(255, 255, 255, 0.7)', flash: 'rgba(255, 255, 255, 0.95)'};
        const BIG_SHIP_COLORS = { hull: '#2C2C2C', lines: '#505050', lights: '#FFFF99', engine: '#FF8844' };

        // Gameplay Constants
        const PLAYER_FRICTION = 0.3;
        const STATION_DOCKING_RADIUS_BUFFER = 10; const ASTEROID_COUNT = 20; const ASTEROID_BELT_RADIUS = Math.min(SCREEN_WIDTH, SCREEN_HEIGHT) * 0.35; const ASTEROID_BELT_CENTER_X = SCREEN_WIDTH * 0.7; const ASTEROID_BELT_CENTER_Y = SCREEN_HEIGHT * 0.5; const ASTEROID_WOBBLE_SPEED = 0.5; const ASTEROID_WOBBLE_AMOUNT = 0.05; const STAR_COUNT = 200; const NPC_COUNT = 5; const NPC_SPEED_MIN = 30; const NPC_SPEED_MAX = 60; const NPC_DESPAWN_BUFFER = 250; const LOCAL_CHAT_RANGE = 150; const LOCAL_CHAT_COOLDOWN = 3000; const LOCAL_CHAT_DURATION = 5000; const TICKER_MAX_MESSAGES = 5; const ISK_PER_VELDSPAR_UNIT = 15; const PLEX_TIME_INITIAL = 600; const PLEX_COST_ISK = 5000; const PLEX_TIME_VALUE = 300; const PLEX_WARNING_THRESHOLD = 0.25; const PLEX_CRITICAL_THRESHOLD = 0.10; const CONCORD_SPEED = 100; const CONCORD_IMPOUND_RANGE = 50; const CONCORD_FINISH_DELAY = 4; const FLEET_BATTLE_CHANCE_PER_SECOND = 0.005; const FLEET_BATTLE_MIN_COOLDOWN = 180; const FLEET_BATTLE_MAX_COOLDOWN = 600; const DISTANT_BATTLE_RADIUS = 150; const DISTANT_SHIP_COUNT = 30; const DISTANT_SHIP_SPEED = 5; const BATTLE_VISUAL_DURATION = 20; const TIDI_ENGAGE_DURATION = 15; const TIDI_RESOLVE_DELAY = 3; const TIDI_FACTOR_LOW = 0.12; const TIDI_FACTOR_RECOVERED = 0.87; const AFTERMATH_CHANCE = 0.15; const CYNO_CHANCE_PER_SECOND = 0.008; const CYNO_MIN_COOLDOWN = 120; const CYNO_MAX_COOLDOWN = 480; const CYNO_FORM_DURATION = 1.5; const CYNO_PULSE_DURATION = 3.0; const CYNO_FLASH_DURATION = 0.2; const CYNO_FADE_DURATION = 1.0; const CYNO_MAX_RADIUS = 60; const CYNO_LIGHTNING_CHANCE = 0.2; const CYNO_LIGHTNING_DURATION = 0.15; const BIG_SHIP_MIN_SIZE = { w: 120, h: 40 }; const BIG_SHIP_MAX_SIZE = { w: 200, h: 80 }; const BIG_SHIP_SPEED_MIN = 5; const BIG_SHIP_SPEED_MAX = 15; const BIG_SHIP_DESPAWN_BUFFER = 300;

        // Black Market Constants
        const BLACK_MARKET_ENTRY_ISK = 7770;
        const BLACK_MARKET_HTML_FILE = "JitaBM.html";

        // Local Chat Messages
        const LOCAL_CHAT_MESSAGES = [ "o7", "o7", "o7 CMDR", "7o", "hi", "sup", "yo", "Clear", "Clear?", "System clear.", "gf", "gf", "gf!", "Good fight.", "Was close.", "Nice brawl.", "Well played.", "?", "¿", ".", "..", "...", "Anyone seen any good belts around?", "This belt is dry.", "Any roids left?", "Veldspar prices holding?", "Need boosts?", "Orca on grid?", "Mining permit check!", "Show permit!", "Need cyno for hauler.", "Jump freighter moving.", "Industry jobs done.", "Building components.", "Planetary interaction update?", "Jetcan full.", "Can someone scoop my can?", "Watch out for ninjas.", "AFK mining.", "Gas site found.", "Ice belt depleted.", "Compression array online?", "Moon chunk secured.", "Refinery cycle finishing.", "Need backup in O-VWXB, reds tackled.", "Tackle!", "Point!", "Scram!", "Web!", "Target called.", "Primary is the Drake.", "Switching target.", "Need reps!", "Armor low!", "Shields down!", "Cap stable?", "Neutralizing target.", "Warping fleet.", "Gate is green.", "Gate is red, hold.", "Hold cloak.", "Bubble up!", "Dictor on field.", "Enemy fleet incoming.", "D-scan clear.", "Check D-scan!", "FC, what do?", "Logi anchor up.", "Keep range.", "Burn towards.", "Align out.", "Prop mod on.", "Hotdropping.", "Blops cyno lit.", "Target painted.", "EWAR active.", "Enemy logi is primary.", "Breaking reps.", "Anyone running L4s?", "Blitzing missions.", "Need salvage?", "Wreck field clear.", "Escalation triggered.", "Running DED site.", "Ratting carrier spotted.", "Faction spawn!", "Burner mission active.", "Drifter patrols?", "Triglavian invasion system.", "Emerging Conduit.", "Forward operating base nearby.", "Incursion fleet forming?", "Sansha scouts.", "Guristas hideout.", "Blood Raider covenant.", "Angel Cartel presence.", "WTS [Item Name], PST.", "WTB Tritanium bulk.", "Price check on PLEX.", "Jita running slow?", "Contract up.", "Public courier available.", "Scam alert in local.", "Check market orders.", "Undercutting again...", "Need appraisal.", "Blue loot value?", "Sell orders filled.", "Buying skill injectors.", "Amarr Victor!", "For the State!", "Gallente strong!", "Freedom for Matar!", "Jove space secure?", "Remember the Titan.", "Empress Catiz watching.", "Federation Day soon.", "Tribal Council meets.", "CONCORD response time?", "Is that a Jovian ship?", "Never forget Seyllin.", "The Sleeper stirs.", "Triglavian Collective communication intercepted.", "Zorya's gaze.", "What are the Drifters planning?", "Echoes from the Abyss.", "Capsuleer immortality...", "Clone bay operational.", "Neural interface stable.", "Can I bring my Drake?", "TEST alliance best alliance.", "Keepstar down!", "Awoxing attempt failed.", "FC, I'm tackled.", "Already replaced.", "Spin ship in station.", "Docking request denied.", "Wrong overview tab.", "Friendly fire incident.", "Who shot the structure?", "Need more spreadsheets.", "EVE is real.", "Slow day.", "AFK", "BRB bio.", "Who's flying that?", "Nice paint job.", "New ship smell.", "Just passing through.", "Lost connection.", "Server hamster needs feeding.", "Warp drive active.", "Autopilot engaged.", "System laggy.", "Anyone else getting disconnects?", "Time dilation factor?", "Traffic control busy.", "Undocking now.", "Pod express.", "Jump clone ready.", "Long trip ahead." ];

        // --- Asset Rendering ---
        const sprites = { player: null, player_thrust: null, station: null, asteroid: null, npc_frigate: null, npc_hauler: null, concord_ship: null };
        const spriteData = {
             player: { width: 16, height: 16, pixels: [ 0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0, 0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0, 0,0,0,0,1,1,1,3,3,1,1,1,0,0,0,0, 0,0,0,1,1,1,1,3,3,1,1,1,1,0,0,0, 0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0, 1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1, 0,2,2,0,0,0,0,0,0,0,0,0,0,2,2,0, 0,2,2,0,0,0,0,0,0,0,0,0,0,2,2,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] },
            station: { width: 48, height: 48, pixels: [] }, // Placeholder, generated in loadAssets
            asteroid: { width: 24, height: 24, pixels: [] }, // Placeholder, generated in loadAssets
            npc_frigate: { width: 14, height: 18, pixels: [ 0,0,0,0,0,0,1,1,0,0,0,0,0,0, 0,0,0,0,0,1,1,1,1,0,0,0,0,0, 0,0,0,0,1,1,1,1,1,1,0,0,0,0, 0,0,0,1,1,1,3,3,1,1,1,0,0,0, 0,0,1,1,1,1,1,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1,1,1,1,1,1,0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0,2,1,1,1,1,1,1,1,1,1,1,2,0, 0,2,2,1,1,1,1,1,1,1,2,2,0,0, 0,0,2,2,1,1,1,1,1,1,2,2,0,0, 0,0,0,2,2,1,1,1,1,2,2,0,0,0, 0,0,0,0,2,2,1,1,2,2,0,0,0,0, 0,0,0,0,0,2,2,2,2,0,0,0,0,0, 0,0,0,0,0,0,2,2,0,0,0,0,0,0, 0,0,0,0,0,0,2,2,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] },
            npc_hauler: { width: 22, height: 20, pixels: [ 0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0, 0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0, 0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0, 0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0, 0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0, 0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0, 0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0, 0,0,0,0,2,2,1,1,1,0,0,0,0,1,1,1,2,2,0,0,0,0, 0,0,0,0,0,2,2,1,0,0,0,0,0,0,1,2,2,0,0,0,0,0, 0,0,0,0,0,0,2,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] },
            concord_ship: { width: 14, height: 18, pixels: [ 0,0,0,0,0,0,1,1,0,0,0,0,0,0, 0,0,0,0,0,1,1,1,1,0,0,0,0,0, 0,0,0,0,1,1,1,1,1,1,0,0,0,0, 0,0,0,1,1,1,3,3,1,1,1,0,0,0, 0,0,1,1,1,1,1,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1,1,1,1,1,1,0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0,2,1,1,1,1,1,1,1,1,1,1,2,0, 0,2,2,1,1,1,1,1,1,1,2,2,0,0, 0,0,2,2,1,1,1,1,1,1,2,2,0,0, 0,0,0,2,2,1,1,1,1,2,2,0,0,0, 0,0,0,0,2,2,1,1,2,2,0,0,0,0, 0,0,0,0,0,2,2,2,2,0,0,0,0,0, 0,0,0,0,0,0,2,2,0,0,0,0,0,0, 0,0,0,0,0,0,2,2,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] }
        };
        // *** DIAGNOSTIC: Wrap potentially failing function ***
        function safeCreatePixelSprite(data, colorMap) {
            try {
                return createPixelSprite(data, colorMap);
            } catch (error) {
                console.error(`DIAGNOSTIC: Error in createPixelSprite for data (width ${data?.width}):`, error);
                // Return a dummy canvas or null to prevent further errors down the line
                const dummyCanvas = document.createElement('canvas');
                dummyCanvas.width = data?.width || 16;
                dummyCanvas.height = data?.height || 16;
                return dummyCanvas;
            }
        }
        function createPixelSprite(data, colorMap) { const canvas = document.createElement('canvas'); canvas.width = data.width; canvas.height = data.height; const ctx = canvas.getContext('2d'); if (!data.pixels || data.pixels.length === 0) return canvas; const imgData = ctx.createImageData(data.width, data.height); const pixels = imgData.data; for (let i = 0; i < data.pixels.length; i++) { const colorIndex = data.pixels[i]; let color = [0, 0, 0, 0]; if (colorIndex === 1) color = hexToRgba(colorMap.main); else if (colorIndex === 2) color = hexToRgba(colorMap.trim); else if (colorIndex === 3) color = hexToRgba(colorMap.cockpit || colorMap.lights_off); else if (colorIndex === 4) color = hexToRgba(colorMap.thrust); const pixelIndex = i * 4; pixels[pixelIndex] = color[0]; pixels[pixelIndex + 1] = color[1]; pixels[pixelIndex + 2] = color[2]; pixels[pixelIndex + 3] = color[3]; } ctx.putImageData(imgData, 0, 0); return canvas; }
        function hexToRgba(hex, alpha = 255) { if (!hex) return [0,0,0,0]; const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return [r, g, b, alpha]; }
        function generateAsteroidPixels(width, height, colors) { let pixels = []; const centerX = width / 2; const centerY = height / 2; const baseRadius = Math.min(width, height) / 2 * 0.8; for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const dx = x - centerX; const dy = y - centerY; const dist = Math.sqrt(dx * dx + dy * dy); const angle = Math.atan2(dy, dx); const wobble = Math.sin(angle * 5 + x * 0.2 + y * 0.1) * baseRadius * 0.2; const currentRadius = baseRadius + wobble; if (dist < currentRadius) { const noise = Math.random(); if (noise < 0.6) pixels.push(1); else if (noise < 0.85) pixels.push(2); else pixels.push(3); } else { pixels.push(0); } } } return { width, height, pixels }; }


        // --- Game State Variables ---
        let PLAYER_THRUST_POWER = BASE_PLAYER_THRUST_POWER;
        let PLAYER_TURN_RATE = BASE_PLAYER_TURN_RATE;
        let PLAYER_MAX_CARGO = BASE_PLAYER_MAX_CARGO;
        let MINING_RATE = BASE_MINING_RATE;
        let MINING_RANGE = BASE_MINING_RANGE;

        let player = {
            x: SCREEN_WIDTH / 4, y: SCREEN_HEIGHT / 2, vx: 0, vy: 0, angle: -Math.PI / 2,
            cargo: 0, isMining: false, miningTarget: null, isThrusting: false,
            sprite: null, thrustSprite: null,
            purchasedItems: [],
            hasIntelLogger: false,
            collectedIntelLogs: []
        };
        let station = { x: SCREEN_WIDTH / 4, y: SCREEN_HEIGHT / 2, radius: 50, sprite: null, lightBlinkTimer: 0, lightState: false };
        let asteroids = []; let stars = []; let particles = []; let npcs = []; let interceptedMessages = []; let isk = 0; let plexTimeRemaining = PLEX_TIME_INITIAL; let isGameOver = false; let concordShip = null; let concordState = 'idle'; let gameOverTimer = 0; let keys = {}; let lastTime = 0; let messageTimeout = null; let assetsLoaded = false; let lastLocalChatTime = 0; let plexWarningShown = { warning: false, critical: false }; let isFleetBattleActive = false; let fleetBattlePhase = 'idle'; let fleetBattleTimer = 0; let fleetBattleCooldown = 30; let fleetBattleLocation = { x: 0, y: 0, radius: 0 }; let distantShips = []; let distantEffects = []; let tidiFactor = 1.0; let tidiTargetFactor = 1.0; let isCynoActive = false; let cynoPhase = 'idle'; let cynoTimer = 0; let cynoLocation = { x: 0, y: 0, currentRadius: 0, alpha: 1.0, lightningBolts: [] }; let cynoCooldown = 45; let bigShip = null; let isDocked = false;
        let haxIndicatorTimeout = null;

        // --- Helper Functions ---
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function showMessage(text, duration = 2000, isChat = false) { if (isGameOver && concordState !== 'finished' && !text.toLowerCase().includes('concord')) return; messageEl.textContent = text; messageEl.style.display = 'block'; if (isChat) { messageEl.classList.add('local-chat'); } else { messageEl.classList.remove('local-chat'); } if (messageTimeout) clearTimeout(messageTimeout); messageTimeout = setTimeout(() => { messageEl.style.display = 'none'; messageEl.classList.remove('local-chat'); }, duration); }
        function createParticles(x, y, count, colorList, speedRange, lifeRange) { try { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = speedRange[0] + Math.random() * (speedRange[1] - speedRange[0]); particles.push({ x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: lifeRange[0] + Math.random() * (lifeRange[1] - lifeRange[0]), color: colorList[Math.floor(Math.random() * colorList.length)], size: 1 + Math.random() * 2 }); } } catch(e) {console.error("DIAGNOSTIC: Error in createParticles", e)} }
        function updateTickerDisplay() { if (!tickerEl) return; try { const title = tickerEl.querySelector('#ticker-title'); tickerEl.innerHTML = ''; if (title) tickerEl.appendChild(title); interceptedMessages.forEach(msg => { const p = document.createElement('p'); p.textContent = msg; tickerEl.appendChild(p); }); } catch(e) {console.error("DIAGNOSTIC: Error in updateTickerDisplay", e)} }
        function updatePlexBar() { try { const plexPercent = Math.max(0, plexTimeRemaining / PLEX_TIME_INITIAL) * 100; plexBarFillEl.style.width = `${plexPercent}%`; plexBarContainerEl.classList.remove('warning', 'critical'); plexWarningShown.warning = false; plexWarningShown.critical = false; if (plexPercent <= PLEX_CRITICAL_THRESHOLD * 100) { plexBarContainerEl.classList.add('critical'); plexWarningShown.critical = true; } else if (plexPercent <= PLEX_WARNING_THRESHOLD * 100) { plexBarContainerEl.classList.add('warning'); plexWarningShown.warning = true; } } catch(e) {console.error("DIAGNOSTIC: Error in updatePlexBar", e)} }
        function showHaxIndicator() { try { if (haxIndicatorTimeout) clearTimeout(haxIndicatorTimeout); haxIndicatorEl.style.display = 'block'; void haxIndicatorEl.offsetWidth; haxIndicatorEl.style.opacity = '1'; haxIndicatorTimeout = setTimeout(() => { haxIndicatorEl.style.opacity = '0'; setTimeout(() => { haxIndicatorEl.style.display = 'none'; }, 300); }, 250); } catch(e) {console.error("DIAGNOSTIC: Error in showHaxIndicator", e)} }

        // --- Initialization Functions ---
        function spawnNPC() { try { const type = Math.random() < 0.5 ? 'frigate' : 'hauler'; let sprite, name, colors; let npcData; if (type === 'frigate') { sprite = sprites.npc_frigate; colors = NPC_FRIGATE_COLORS; name = "Frigate Pilot"; npcData = spriteData.npc_frigate; } else { sprite = sprites.npc_hauler; colors = NPC_HAULER_COLORS; name = "Hauler Captain"; npcData = spriteData.npc_hauler; } let x, y, angle; const edge = Math.floor(Math.random() * 4); const w = npcData.width || 20; const h = npcData.height || 20; switch (edge) { case 0: x = Math.random() * SCREEN_WIDTH; y = -h; angle = Math.random() * Math.PI * 0.8 + Math.PI * 0.1; break; case 1: x = SCREEN_WIDTH + w; y = Math.random() * SCREEN_HEIGHT; angle = Math.random() * Math.PI * 0.8 + Math.PI * 0.6; break; case 2: x = Math.random() * SCREEN_WIDTH; y = SCREEN_HEIGHT + h; angle = Math.random() * Math.PI * 0.8 + Math.PI * 1.1; break; case 3: x = -w; y = Math.random() * SCREEN_HEIGHT; angle = Math.random() * Math.PI * 0.8 - Math.PI * 0.4; break; } const speed = NPC_SPEED_MIN + Math.random() * (NPC_SPEED_MAX - NPC_SPEED_MIN); return { x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, angle: angle, type: type, sprite: sprite, name: name, width: w, height: h }; } catch(e) {console.error("DIAGNOSTIC: Error in spawnNPC", e); return null;} } // Return null on error
        function loadAssets() {
            console.log("DIAGNOSTIC: Starting loadAssets...");
            try {
                sprites.player = safeCreatePixelSprite(spriteData.player, PLAYER_COLORS);
                console.log("DIAGNOSTIC: Player sprite created.");
                let thrustData = JSON.parse(JSON.stringify(spriteData.player));
                thrustData.pixels[11*16 + 6] = 4; thrustData.pixels[11*16 + 7] = 4; thrustData.pixels[11*16 + 8] = 4; thrustData.pixels[11*16 + 9] = 4;
                sprites.player_thrust = safeCreatePixelSprite(thrustData, PLAYER_COLORS);
                player.sprite = sprites.player;
                player.thrustSprite = sprites.player_thrust;
                 console.log("DIAGNOSTIC: Player thrust sprite created.");

                const stationCanvas = document.createElement('canvas'); const sSize = 64; stationCanvas.width = sSize; stationCanvas.height = sSize; const sCtx = stationCanvas.getContext('2d'); sCtx.fillStyle = STATION_COLORS.main; sCtx.strokeStyle = STATION_COLORS.trim; sCtx.lineWidth = 2; sCtx.fillRect(sSize*0.4, 0, sSize*0.2, sSize); sCtx.fillRect(0, sSize*0.4, sSize, sSize*0.2); sCtx.strokeRect(sSize*0.4, 0, sSize*0.2, sSize); sCtx.strokeRect(0, sSize*0.4, sSize, sSize*0.2); sCtx.fillStyle = STATION_COLORS.trim; sCtx.fillRect(sSize*0.35, sSize*0.35, sSize*0.3, sSize*0.3);
                sprites.station = stationCanvas;
                station.sprite = sprites.station;
                station.radius = sSize * 0.4;
                console.log("DIAGNOSTIC: Station sprite created.");

                asteroids = [];
                for (let i = 0; i < ASTEROID_COUNT; i++) {
                    const angle = Math.random() * Math.PI * 2; const dist = ASTEROID_BELT_RADIUS * (0.5 + Math.random() * 0.5); const x = ASTEROID_BELT_CENTER_X + Math.cos(angle) * dist; const y = ASTEROID_BELT_CENTER_Y + Math.sin(angle) * dist; const size = 18 + Math.floor(Math.random() * 15); const resources = Math.floor(size * size / 10 + Math.random() * 50); const asteroidPixelData = generateAsteroidPixels(size, size, ASTEROID_COLORS); const asteroidSprite = safeCreatePixelSprite(asteroidPixelData, { main: ASTEROID_COLORS.main, trim: ASTEROID_COLORS.dark, cockpit: ASTEROID_COLORS.light }); asteroids.push({ x: x, y: y, radius: size / 2, resources: resources, initialResources: resources, sprite: asteroidSprite, angle: Math.random() * Math.PI * 2, wobbleOffset: Math.random() * Math.PI * 2 });
                }
                console.log("DIAGNOSTIC: Asteroids created.");

                stars = []; for (let i = 0; i < STAR_COUNT; i++) { stars.push({ x: Math.random() * SCREEN_WIDTH, y: Math.random() * SCREEN_HEIGHT, size: Math.random() * 1.5 + 0.5, brightness: 0.5 + Math.random() * 0.5 }); }
                console.log("DIAGNOSTIC: Stars created.");

                sprites.npc_frigate = safeCreatePixelSprite(spriteData.npc_frigate, NPC_FRIGATE_COLORS);
                sprites.npc_hauler = safeCreatePixelSprite(spriteData.npc_hauler, NPC_HAULER_COLORS);
                sprites.concord_ship = safeCreatePixelSprite(spriteData.concord_ship, CONCORD_COLORS);
                 console.log("DIAGNOSTIC: NPC/Concord sprites created.");

                npcs = []; for (let i = 0; i < NPC_COUNT; i++) { const newNpc = spawnNPC(); if (newNpc) npcs.push(newNpc); } // Check if spawnNPC worked
                console.log("DIAGNOSTIC: Initial NPCs spawned.");

                updateTickerDisplay();
                updatePlexBar();
                console.log("DIAGNOSTIC: Setting assetsLoaded = true");
                assetsLoaded = true;
                console.log("DIAGNOSTIC: assetsLoaded is now true. loadAssets complete.");

            } catch (error) {
                 console.error("DIAGNOSTIC: CRITICAL ERROR during loadAssets:", error);
                 alert("DIAGNOSTIC: Error during asset loading! Check console (F12).");
                 // Do not set assetsLoaded = true if error occurs
            }
        }
        function startGameover() { if (isGameOver) return; console.log("GAME OVER: PLEX Expired!"); isGameOver = true; isCynoActive = false; tidiFactor = 1.0; tidiTargetFactor = 1.0; document.body.classList.remove('tidi-active'); isFleetBattleActive = false; fleetBattlePhase = 'idle'; concordState = 'approaching'; const spawnEdge = Math.floor(Math.random() * 4); let sx, sy; const buffer = 50; if (spawnEdge === 0) { sx = Math.random() * SCREEN_WIDTH; sy = -buffer; } else if (spawnEdge === 1) { sx = SCREEN_WIDTH + buffer; sy = Math.random() * SCREEN_HEIGHT; } else if (spawnEdge === 2) { sx = Math.random() * SCREEN_WIDTH; sy = SCREEN_HEIGHT + buffer; } else { sx = -buffer; sy = Math.random() * SCREEN_HEIGHT; } const angleToPlayer = Math.atan2(player.y - sy, player.x - sx); concordShip = { x: sx, y: sy, vx: Math.cos(angleToPlayer) * CONCORD_SPEED, vy: Math.sin(angleToPlayer) * CONCORD_SPEED, angle: angleToPlayer, sprite: sprites.concord_ship, width: spriteData.concord_ship.width, height: spriteData.concord_ship.height }; messageEl.classList.remove('local-chat'); showMessage("[CONCORD Dispatch]: Capsuleer license expired. Stand down.", 10000); }

        function resetGame() {
            console.log("DIAGNOSTIC: Resetting game state...");
            try {
                isk = 0;
                plexTimeRemaining = PLEX_TIME_INITIAL;
                player.x = station.x + station.radius + (player.sprite ? player.sprite.width : 16);
                player.y = station.y;
                player.vx = 0; player.vy = 0; player.angle = -Math.PI / 2;
                player.cargo = 0;
                player.isMining = false; player.miningTarget = null;
                player.purchasedItems = [];
                player.collectedIntelLogs = [];

                applyItemEffects();

                particles = [];
                interceptedMessages = [];
                isGameOver = false;
                concordShip = null; concordState = 'idle'; gameOverTimer = 0;
                keys = {};
                plexWarningShown = { warning: false, critical: false };

                isFleetBattleActive = false; fleetBattlePhase = 'idle'; distantShips = []; distantEffects = [];
                tidiFactor = 1.0; tidiTargetFactor = 1.0;
                fleetBattleCooldown = FLEET_BATTLE_MIN_COOLDOWN + Math.random() * (FLEET_BATTLE_MAX_COOLDOWN - FLEET_BATTLE_MIN_COOLDOWN);
                isCynoActive = false; cynoPhase = 'idle'; cynoTimer = 0; bigShip = null;
                cynoLocation.lightningBolts = [];
                cynoCooldown = CYNO_MIN_COOLDOWN + Math.random() * (CYNO_MAX_COOLDOWN - CYNO_MIN_COOLDOWN);
                isDocked = false;

                blackMarketButtonEl.style.display = 'none';
                document.body.classList.remove('tidi-active');
                gameOverOverlayEl.style.display = 'none';

                iskEl.textContent = isk;
                cargoEl.textContent = player.cargo;
                intelLogsEl.textContent = player.collectedIntelLogs.length;
                updatePlexBar();
                updateTickerDisplay();

                showMessage("Clone Activated. Welcome back, Capsuleer.", 3000);
                console.log("DIAGNOSTIC: Game reset complete.");
            } catch (error) {
                console.error("DIAGNOSTIC: Error during resetGame:", error);
            }
        }

        // --- Fleet Battle / Cyno / Big Ship Functions (keep same logic) ---
        function startFleetBattle() { /* ... */ }
        function updateFleetBattle(dt) { /* ... */ }
        function addDistantEffect(type) { /* ... */ }
        function endFleetBattle() { /* ... */ }
        function startCynoSequence() { /* ... */ }
        function updateCynoSequence(dt) { /* ... */ }
        function spawnBigShip() { /* ... */ }
        function updateBigShip(dt) { /* ... */ }

        // --- Drawing Functions (keep same logic, add null checks for sprites) ---
        function drawStars() { try { stars.forEach(star => { ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * (0.8 + Math.random()*0.2)})`; ctx.fillRect(star.x - star.size / 2, star.y - star.size / 2, star.size, star.size); }); } catch(e){console.error("DIAGNOSTIC: Draw Stars Error",e)} }
        function drawPlayer() { try { if (isGameOver && concordState !== 'idle') return; const currentSprite = player.isThrusting ? player.thrustSprite : player.sprite; if (!currentSprite) return; ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle + Math.PI / 2); ctx.drawImage(currentSprite, -currentSprite.width / 2, -currentSprite.height / 2); ctx.restore(); } catch(e){console.error("DIAGNOSTIC: Draw Player Error",e)} }
        function drawStation(dt) { try { if (!station.sprite) return; station.lightBlinkTimer += dt; if (station.lightBlinkTimer > 0.5) { station.lightState = !station.lightState; station.lightBlinkTimer = 0; } ctx.save(); ctx.translate(station.x, station.y); ctx.drawImage(station.sprite, -station.sprite.width / 2, -station.sprite.height / 2); const lightSize = 4; ctx.fillStyle = station.lightState ? STATION_COLORS.lights_on : STATION_COLORS.lights_off; ctx.fillRect(-station.sprite.width*0.1 - lightSize/2, -station.sprite.height*0.45 - lightSize/2, lightSize, lightSize); ctx.fillRect(station.sprite.width*0.1 - lightSize/2, -station.sprite.height*0.45 - lightSize/2, lightSize, lightSize); ctx.fillRect(-station.sprite.width*0.45 - lightSize/2, -station.sprite.height*0.1 - lightSize/2, lightSize, lightSize); ctx.fillRect(station.sprite.width*0.45 - lightSize/2, station.sprite.height*0.1 - lightSize/2, lightSize, lightSize); ctx.fillRect(station.sprite.width*0.45 - lightSize/2, -station.sprite.height*0.1 - lightSize/2, lightSize, lightSize); ctx.fillRect(-station.sprite.width*0.45 - lightSize/2, station.sprite.height*0.1 - lightSize/2, lightSize, lightSize); ctx.restore(); ctx.fillStyle = 'white'; ctx.font = '12px monospace'; ctx.textAlign = 'center'; ctx.fillText('Jita 4-4', station.x, station.y + station.radius + 15); } catch(e){console.error("DIAGNOSTIC: Draw Station Error",e)} }
        function drawAsteroids(dt) { try { asteroids.forEach(asteroid => { if (!asteroid.sprite || asteroid.resources <= 0) return; ctx.save(); const wobble = Math.sin(Date.now() * 0.001 * ASTEROID_WOBBLE_SPEED + asteroid.wobbleOffset) * ASTEROID_WOBBLE_AMOUNT; ctx.translate(asteroid.x, asteroid.y); ctx.rotate(asteroid.angle + wobble); ctx.drawImage(asteroid.sprite, -asteroid.sprite.width / 2, -asteroid.sprite.height / 2); ctx.restore(); }); } catch(e){console.error("DIAGNOSTIC: Draw Asteroids Error",e)} }
        function drawMiningBeam() { try { if (isGameOver || !player.isMining || !player.miningTarget) return; const noseOffsetX = Math.cos(player.angle) * (player.sprite ? player.sprite.width * 0.6 : 8); const noseOffsetY = Math.sin(player.angle) * (player.sprite ? player.sprite.width * 0.6 : 8); const startX = player.x + noseOffsetX; const startY = player.y + noseOffsetY; const endX = player.miningTarget.x; const endY = player.miningTarget.y; const pulse = (Math.sin(Date.now() * 0.01) + 1) / 2; const gradient = ctx.createLinearGradient(startX, startY, endX, endY); gradient.addColorStop(0, MINING_BEAM_COLOR_START); gradient.addColorStop(0.5 + pulse * 0.3, MINING_BEAM_COLOR_END); gradient.addColorStop(1, 'rgba(255,0,0,0)'); ctx.strokeStyle = gradient; ctx.lineWidth = 2 + pulse * 2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke(); } catch(e){console.error("DIAGNOSTIC: Draw Mining Beam Error",e)} }
        function drawParticles(dt) { try { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt; if (p.life <= 0) { particles.splice(i, 1); } else { ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life / 0.5); ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size); } } ctx.globalAlpha = 1.0; } catch(e){console.error("DIAGNOSTIC: Draw Particles Error",e)} }
        function drawNPCs(dt) { try { npcs.forEach(npc => { if (!npc || !npc.sprite) return; ctx.save(); ctx.translate(npc.x, npc.y); ctx.rotate(npc.angle + Math.PI / 2); ctx.drawImage(npc.sprite, -npc.width / 2, -npc.height / 2); ctx.restore(); }); } catch(e){console.error("DIAGNOSTIC: Draw NPCs Error",e)} }
        function drawConcordShip() { try { if (!isGameOver || !concordShip || !concordShip.sprite) return; ctx.save(); ctx.translate(concordShip.x, concordShip.y); ctx.rotate(concordShip.angle + Math.PI / 2); ctx.drawImage(concordShip.sprite, -concordShip.width / 2, -concordShip.height / 2); ctx.restore(); } catch(e){console.error("DIAGNOSTIC: Draw Concord Error",e)} }
        function drawDistantBattle(ctx) { try { if (!isFleetBattleActive) return; ctx.save(); ctx.lineWidth = 1; distantEffects.forEach(effect => { ctx.globalAlpha = Math.max(0, effect.life / 0.5); if (effect.type === 'beam') { ctx.strokeStyle = effect.color; ctx.beginPath(); ctx.moveTo(effect.x1, effect.y1); ctx.lineTo(effect.x2, effect.y2); ctx.stroke(); } else if (effect.type === 'explosion') { ctx.fillStyle = effect.color; ctx.beginPath(); const currentRadius = effect.radius * (1 - Math.abs(effect.life - 0.5) / 0.5); ctx.arc(effect.x, effect.y, Math.max(1, currentRadius), 0, Math.PI * 2); ctx.fill(); } }); ctx.globalAlpha = tidiFactor < 0.9 ? 0.6 : 1.0; distantShips.forEach(ship => { ctx.fillStyle = ship.color; ctx.fillRect(ship.x - 1, ship.y - 1, 2, 2); }); ctx.restore(); } catch(e){console.error("DIAGNOSTIC: Draw Distant Battle Error",e)} }
        function drawCynoField(ctx) { try { if (!isCynoActive || cynoLocation.alpha <= 0) return; ctx.save(); const x = cynoLocation.x; const y = cynoLocation.y; let baseAlpha = cynoLocation.alpha; let effectRadius = cynoLocation.currentRadius; if (cynoPhase === 'flash_in' || cynoPhase === 'flash_out') { const flashProgress = Math.max(0, cynoTimer / CYNO_FLASH_DURATION); const flashIntensity = 1.0 - Math.abs(0.5 - flashProgress) * 2; baseAlpha = 1.0; ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.9})`; ctx.beginPath(); ctx.arc(x, y, CYNO_MAX_RADIUS * (1 + flashIntensity * 0.3), 0, Math.PI * 2); ctx.fill(); } if (cynoPhase === 'pulsing') { const pulseFactor = (Math.sin(Date.now() * 0.015) + 1) / 2; baseAlpha = 0.8 + pulseFactor * 0.2; effectRadius = CYNO_MAX_RADIUS * (0.95 + pulseFactor * 0.1); } ctx.globalAlpha = baseAlpha; ctx.fillStyle = CYNO_COLORS.edge; ctx.beginPath(); ctx.arc(x, y, effectRadius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = CYNO_COLORS.middle; ctx.beginPath(); ctx.arc(x, y, effectRadius * 0.6, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = CYNO_COLORS.center; ctx.beginPath(); ctx.arc(x, y, effectRadius * 0.2, 0, Math.PI * 2); ctx.fill(); if (cynoPhase === 'pulsing' && cynoLocation.lightningBolts.length > 0) { ctx.strokeStyle = CYNO_COLORS.lightning; ctx.lineWidth = 1.5; cynoLocation.lightningBolts.forEach(bolt => { ctx.globalAlpha = baseAlpha * (bolt.life / CYNO_LIGHTNING_DURATION); const endX = x + Math.cos(bolt.angle) * bolt.endRadius; const endY = y + Math.sin(bolt.angle) * bolt.endRadius; const midX = x + Math.cos(bolt.angle) * bolt.endRadius * 0.5 + (Math.random() - 0.5) * 10; const midY = y + Math.sin(bolt.angle) * bolt.endRadius * 0.5 + (Math.random() - 0.5) * 10; ctx.beginPath(); ctx.moveTo(x, y); ctx.quadraticCurveTo(midX, midY, endX, endY); ctx.stroke(); }); } ctx.restore(); } catch(e){console.error("DIAGNOSTIC: Draw Cyno Error",e)} }
        function drawBigShip(ctx) { try { if (!bigShip) return; ctx.save(); ctx.translate(bigShip.x, bigShip.y); ctx.rotate(bigShip.angle + Math.PI / 2); ctx.fillStyle = BIG_SHIP_COLORS.hull; ctx.fillRect(-bigShip.width / 2, -bigShip.height / 2, bigShip.width, bigShip.height); ctx.strokeStyle = BIG_SHIP_COLORS.lines; ctx.lineWidth = 1; ctx.strokeRect(-bigShip.width / 2, -bigShip.height / 2, bigShip.width, bigShip.height); ctx.beginPath(); ctx.moveTo(0, -bigShip.height / 2); ctx.lineTo(0, bigShip.height / 2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-bigShip.width * 0.4, -bigShip.height * 0.3); ctx.lineTo(bigShip.width * 0.4, -bigShip.height * 0.3); ctx.stroke(); ctx.fillStyle = BIG_SHIP_COLORS.lights; if (Math.random() < 0.1) { ctx.fillRect(-bigShip.width * 0.4, bigShip.height * 0.4, 4, 4); ctx.fillRect(bigShip.width * 0.4 - 4, bigShip.height * 0.4, 4, 4); ctx.fillRect(-2, -bigShip.height * 0.45, 4, 2); } ctx.fillStyle = BIG_SHIP_COLORS.engine; const engineGlow = (Math.sin(Date.now()*0.005) + 1) * 3 + 2; ctx.fillRect(-bigShip.width * 0.2, bigShip.height * 0.5 - engineGlow/2, bigShip.width * 0.4, engineGlow); ctx.restore(); } catch(e){console.error("DIAGNOSTIC: Draw Big Ship Error",e)} }

        // --- Game Logic (Update) ---
        function handleInput(dt) { try { if (isGameOver) { if (keys['enter']) { resetGame(); keys['enter'] = false; } return; } player.isThrusting = false; if (keys['a'] || keys['arrowleft']) player.angle -= PLAYER_TURN_RATE * dt; if (keys['d'] || keys['arrowright']) player.angle += PLAYER_TURN_RATE * dt; if (keys['w'] || keys['arrowup']) { player.vx += Math.cos(player.angle) * PLAYER_THRUST_POWER * dt; player.vy += Math.sin(player.angle) * PLAYER_THRUST_POWER * dt; player.isThrusting = true; } if (keys['m']) { if (!player.isMining) { let closestAsteroid = null; let minDist = Infinity; asteroids.forEach(asteroid => { if (asteroid.resources > 0) { const d = distance(player.x, player.y, asteroid.x, asteroid.y) - asteroid.radius; if (d < MINING_RANGE && d < minDist) { minDist = d; closestAsteroid = asteroid; } } }); if (closestAsteroid && player.cargo < PLAYER_MAX_CARGO) { player.isMining = true; player.miningTarget = closestAsteroid; } else if (player.cargo >= PLAYER_MAX_CARGO) { showMessage("Cargo hold is full!", 1500); } else if (!closestAsteroid) { showMessage("No Veldspar in range.", 1500); } } keys['m'] = false; } if (keys['l']) { const now = performance.now(); if (now - lastLocalChatTime > LOCAL_CHAT_COOLDOWN) { let closestNPC = null; let minDist = LOCAL_CHAT_RANGE; npcs.forEach(npc => { if(!npc) return; const d = distance(player.x, player.y, npc.x, npc.y); if (d < minDist) { minDist = d; closestNPC = npc; } }); if (closestNPC) { const randomMsg = LOCAL_CHAT_MESSAGES[Math.floor(Math.random() * LOCAL_CHAT_MESSAGES.length)]; const formattedMsg = `[${closestNPC.name}]: ${randomMsg}`; showMessage(formattedMsg, LOCAL_CHAT_DURATION, true); lastLocalChatTime = now; interceptedMessages.unshift(formattedMsg); if (interceptedMessages.length > TICKER_MAX_MESSAGES) { interceptedMessages.pop(); } updateTickerDisplay(); if (player.hasIntelLogger) { player.collectedIntelLogs.push(formattedMsg); intelLogsEl.textContent = player.collectedIntelLogs.length; } } } keys['l'] = false; } if (keys['p']) { if (isDocked) { if (isk >= PLEX_COST_ISK) { isk -= PLEX_COST_ISK; plexTimeRemaining += PLEX_TIME_VALUE; plexTimeRemaining = Math.min(plexTimeRemaining, PLEX_TIME_INITIAL); iskEl.textContent = Math.floor(isk); updatePlexBar(); showMessage(`PLEX Activated! License extended by ${PLEX_TIME_VALUE / 60} mins.`, 2500); plexWarningShown.warning = false; plexWarningShown.critical = false; } else { showMessage(`Insufficient ISK. Need ${PLEX_COST_ISK.toLocaleString()} ISK for PLEX.`, 2000); } } else { showMessage("Must be docked at Jita 4-4 to purchase PLEX.", 2000); } keys['p'] = false; } if (keys['3']) { isk += 333; iskEl.textContent = Math.floor(isk); showHaxIndicator(); console.log("Cheat: +333 ISK"); keys['3'] = false; } if (keys['[']) { startCynoSequence(); keys['['] = false; } if (keys[']']) { startFleetBattle(); keys[']'] = false; } } catch(e){console.error("DIAGNOSTIC: Error in handleInput",e)} }
        function updateGameOver(dt) { try { if (!isGameOver || !concordShip) return; if (concordState === 'approaching') { const angleToPlayer = Math.atan2(player.y - concordShip.y, player.x - concordShip.x); concordShip.vx = Math.cos(angleToPlayer) * CONCORD_SPEED; concordShip.vy = Math.sin(angleToPlayer) * CONCORD_SPEED; concordShip.angle = angleToPlayer; concordShip.x += concordShip.vx * dt; concordShip.y += concordShip.vy * dt; const distToConcord = distance(player.x, player.y, concordShip.x, concordShip.y); if (distToConcord < CONCORD_IMPOUND_RANGE) { concordState = 'impounding'; concordShip.vx = 0; concordShip.vy = 0; messageEl.classList.remove('local-chat'); showMessage("[CONCORD Enforcer]: Vessel remote operation protocols suspended. Impounding...", 10000); createParticles(player.x, player.y, 50, CONCORD_COLORS.trim === '#FFFFFF' ? ['#FFFFFF', '#DDDDFF', '#BBBBFF'] : [CONCORD_COLORS.trim, CONCORD_COLORS.cockpit || '#FFFFFF'], [30, 80], [0.5, 1.2]); gameOverTimer = CONCORD_FINISH_DELAY; } } else if (concordState === 'impounding') { gameOverTimer -= dt; if (gameOverTimer <= 0) { concordState = 'finished'; finalIskEl.textContent = Math.floor(isk); gameOverOverlayEl.style.display = 'flex'; if (messageTimeout) clearTimeout(messageTimeout); messageEl.style.display = 'none'; } } } catch(e){console.error("DIAGNOSTIC: Error in updateGameOver",e)} }

        function update(dt) {
            try {
                if (!assetsLoaded) return; // Don't update if assets aren't ready
                if (isGameOver) { updateGameOver(dt); updateParticles(dt); updateBigShip(dt); return; }

                const effectiveDt = dt / tidiFactor;

                if (!isFleetBattleActive && !isCynoActive) { fleetBattleCooldown -= effectiveDt; if (fleetBattleCooldown <= 0 && Math.random() < FLEET_BATTLE_CHANCE_PER_SECOND * effectiveDt) { startFleetBattle(); } cynoCooldown -= effectiveDt; if (cynoCooldown <= 0 && Math.random() < CYNO_CHANCE_PER_SECOND * effectiveDt) { startCynoSequence(); } }
                if (isFleetBattleActive) { updateFleetBattle(dt); }
                if (isCynoActive) { updateCynoSequence(dt); }
                updateBigShip(dt);

                plexTimeRemaining -= effectiveDt; updatePlexBar(); if (plexTimeRemaining <= 0 && !isGameOver) { startGameover(); return; }
                const plexPercent = plexTimeRemaining / PLEX_TIME_INITIAL; if (plexPercent <= PLEX_CRITICAL_THRESHOLD && !plexWarningShown.critical && !isGameOver) { showMessage("WARNING: Capsule license critically low! Immediate renewal required!", 4000); plexWarningShown.critical = true; } else if (plexPercent <= PLEX_WARNING_THRESHOLD && !plexWarningShown.warning && !isGameOver) { showMessage("Caution: Capsule license running low. Consider PLEX renewal.", 3500); plexWarningShown.warning = true; }

                player.vx *= (1 - PLAYER_FRICTION * effectiveDt); player.vy *= (1 - PLAYER_FRICTION * effectiveDt); player.x += player.vx * effectiveDt; player.y += player.vy * effectiveDt;
                const pw = player.sprite ? player.sprite.width / 2 : 8; const ph = player.sprite ? player.sprite.height / 2 : 8; if (player.x < -pw) player.x = SCREEN_WIDTH + pw; if (player.x > SCREEN_WIDTH + pw) player.x = -pw; if (player.y < -ph) player.y = SCREEN_HEIGHT + ph; if (player.y > SCREEN_HEIGHT + ph) player.y = -ph;

                if (player.isMining) { if (!player.miningTarget || player.miningTarget.resources <= 0) { player.isMining = false; player.miningTarget = null; } else { const distToTarget = distance(player.x, player.y, player.miningTarget.x, player.miningTarget.y); const effectiveRange = MINING_RANGE + player.miningTarget.radius; if (distToTarget > effectiveRange * 1.05) { player.isMining = false; player.miningTarget = null; showMessage("Target out of range", 1500); } else if (player.cargo < PLAYER_MAX_CARGO) { const minedAmount = MINING_RATE * effectiveDt; const actualMined = Math.min(minedAmount, player.miningTarget.resources); const cargoSpace = PLAYER_MAX_CARGO - player.cargo; const actualStored = Math.min(actualMined, cargoSpace); player.miningTarget.resources -= actualStored; player.cargo += actualStored; cargoEl.textContent = Math.floor(player.cargo); if (Math.random() < 0.1) { createParticles(player.miningTarget.x, player.miningTarget.y, 1, [ASTEROID_COLORS.light], [5,15], [0.2, 0.4]); } if (player.cargo >= PLAYER_MAX_CARGO) { player.cargo = PLAYER_MAX_CARGO; player.isMining = false; showMessage("Cargo hold full!", 1500); } if (player.miningTarget.resources <= 0) { const targetX = player.miningTarget.x; const targetY = player.miningTarget.y; player.isMining = false; player.miningTarget = null; createParticles(targetX, targetY, 30, PARTICLE_COLORS, [20, 60], [0.3, 0.8]); showMessage("Veldspar depleted", 1500); } } else { player.isMining = false; } } }

                const distToStation = distance(player.x, player.y, station.x, station.y); const dockRadius = station.radius + (player.sprite ? player.sprite.width / 2 : 10) + STATION_DOCKING_RADIUS_BUFFER; const currentlyDocked = distToStation < dockRadius;
                if (currentlyDocked) { if (!isDocked) { isDocked = true; console.log("Docked at Jita 4-4"); player.isMining = false; player.miningTarget = null; if (player.cargo > 0) { const cargoValue = Math.floor(player.cargo); const earnedISK = cargoValue * ISK_PER_VELDSPAR_UNIT; isk += earnedISK; showMessage(`Sold ${cargoValue} units of Veldspar for ${earnedISK.toLocaleString()} ISK.`, 2500); player.cargo = 0; iskEl.textContent = Math.floor(isk); cargoEl.textContent = '0'; } else { showMessage("Docking request accepted. Welcome to Jita 4-4.", 2000); } } const dx = station.x - player.x; const dy = station.y - player.y; const DOCK_PULL_FACTOR = 0.2; const MAX_DOCK_SPEED_SQ = 100; if (player.vx * player.vx + player.vy * player.vy > MAX_DOCK_SPEED_SQ) { player.vx *= 0.95; player.vy *= 0.95; } player.vx += dx * effectiveDt * DOCK_PULL_FACTOR; player.vy += dy * effectiveDt * DOCK_PULL_FACTOR; if (isk >= BLACK_MARKET_ENTRY_ISK) { blackMarketButtonEl.style.display = 'block'; } else { blackMarketButtonEl.style.display = 'none'; } } else { if (isDocked) { isDocked = false; console.log("Undocked from Jita 4-4"); showMessage("Undocking complete. Have a safe flight.", 2000); blackMarketButtonEl.style.display = 'none'; } }

                for (let i = npcs.length - 1; i >= 0; i--) { const npc = npcs[i]; if (!npc) { npcs.splice(i,1); continue; } // Safety check
                 npc.x += npc.vx * effectiveDt; npc.y += npc.vy * effectiveDt; const despawnEdge = NPC_DESPAWN_BUFFER + Math.max(npc.width || 0, npc.height || 0); if (npc.x < -despawnEdge || npc.x > SCREEN_WIDTH + despawnEdge || npc.y < -despawnEdge || npc.y > SCREEN_HEIGHT + despawnEdge) { npcs.splice(i, 1); const newNpc = spawnNPC(); if (newNpc) npcs.push(newNpc); } } // Replace with new valid NPC

                updateParticles(dt);
            } catch (error) {
                console.error("DIAGNOSTIC: Error in update function:", error);
                isGameOver = true; // Try to stop the game on update error
                showMessage("CRITICAL ERROR IN UPDATE - CHECK CONSOLE", 10000);
            }
        }

        function updateParticles(dt) { try { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt; if (p.life <= 0) { particles.splice(i, 1); } } } catch(e){console.error("DIAGNOSTIC: Error in updateParticles",e)} }

        // --- Render Function ---
        function render(dt) {
            // *** DIAGNOSTIC: Check if render loop is running and assets are loaded ***
             //console.log(`DIAGNOSTIC: Render tick. assetsLoaded: ${assetsLoaded}`); // Too spammy, check gameLoop log instead

            if (!assetsLoaded) {
                // Draw loading screen ONLY if context is available
                if (ctx) {
                    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.fillStyle = 'white'; ctx.font = '20px monospace'; ctx.textAlign = 'center';
                    ctx.fillText('Loading Assets...', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
                }
                return; // Stop rendering if assets aren't loaded
            }

            // *** DIAGNOSTIC: If assets are loaded, rendering should happen ***
            // console.log("DIAGNOSTIC: Assets loaded, proceeding with render.");

            try {
                // Clear screen
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                // Draw layers (background to foreground)
                drawStars();
                drawDistantBattle(ctx);
                drawCynoField(ctx);
                drawBigShip(ctx);
                drawStation(dt);
                drawAsteroids(dt);
                drawNPCs(dt);
                drawParticles(dt);
                drawMiningBeam();
                drawPlayer();
                drawConcordShip();

                // Draw TiDi effect overlay if active
                if (tidiFactor < 0.95) { const tidiAlpha = (1.0 - tidiFactor) * 0.2; ctx.fillStyle = `rgba(120, 50, 150, ${tidiAlpha})`; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); }

            } catch (error) {
                 console.error("DIAGNOSTIC: Error during render function:", error);
                 // Optionally try to draw an error message on canvas
                 if(ctx) {
                     ctx.fillStyle = 'red'; ctx.fillRect(0,0,SCREEN_WIDTH, SCREEN_HEIGHT);
                     ctx.fillStyle = 'white'; ctx.font = '16px monospace'; ctx.textAlign = 'center';
                     ctx.fillText("CRITICAL RENDER ERROR - CHECK CONSOLE", SCREEN_WIDTH/2, SCREEN_HEIGHT/2);
                 }
                 // We might want to stop the game loop here too, but requestAnimationFrame might continue
                 // Setting assetsLoaded = false might prevent further render calls
                 assetsLoaded = false;
            }
        }

        // --- Black Market / Item Effects ---
        function applyItemEffects() {
            //console.log("DIAGNOSTIC: Applying item effects. Current items:", player.purchasedItems.join(', ') || 'None');
            try {
                PLAYER_THRUST_POWER = BASE_PLAYER_THRUST_POWER; PLAYER_TURN_RATE = BASE_PLAYER_TURN_RATE; PLAYER_MAX_CARGO = BASE_PLAYER_MAX_CARGO; MINING_RATE = BASE_MINING_RATE; MINING_RANGE = BASE_MINING_RANGE; player.hasIntelLogger = false;
                let activeModNames = [];
                if (!player.purchasedItems || player.purchasedItems.length === 0) { activeItemDisplayEl.textContent = "Ship Systems: Nominal"; maxCargoEl.textContent = PLAYER_MAX_CARGO; return; }

                player.purchasedItems.forEach(itemId => { let modName = "Unknown Mod"; switch(itemId) { case 'cargo_expander_1': PLAYER_MAX_CARGO += 50; modName = "Cargo Expander I"; break; case 'mining_laser_upgrade_1': MINING_RATE += 10; modName = "MLU-7 'Rockeater'"; break; case 'afterburner_1': PLAYER_THRUST_POWER += 80; modName = "Smuggler's AB"; break; case 'long_range_scanner': MINING_RANGE += 30; modName = "Mod Survey Scanner"; break; case 'intel_logger_1': player.hasIntelLogger = true; modName = "Covert Log Scraper"; break; default: console.warn(`Unknown item ID found: ${itemId}`); break; } if (modName !== "Unknown Mod") { activeModNames.push(modName); } });

                maxCargoEl.textContent = PLAYER_MAX_CARGO;
                if (activeModNames.length > 0) { activeItemDisplayEl.textContent = `Active Mods: ${activeModNames.join(', ')}`; } else { activeItemDisplayEl.textContent = "Ship Systems: Nominal"; }
            } catch(e) {console.error("DIAGNOSTIC: Error in applyItemEffects", e)}
        }

        function loadDataFromUrl() {
            console.log("DIAGNOSTIC: Checking URL for returning data...");
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const returnedItemsStr = urlParams.get('items');
                const returnedIskStr = urlParams.get('isk');
                let didReturnFromBM = false; let newItemsAcquired = [];

                if (returnedItemsStr) { const itemIds = returnedItemsStr.split(','); itemIds.forEach(itemId => { if (itemId && itemId.trim().length > 0) { const trimmedId = itemId.trim(); player.purchasedItems.push(trimmedId); newItemsAcquired.push(trimmedId); } }); if (newItemsAcquired.length > 0) { console.log(`Added items from BM: [${newItemsAcquired.join(', ')}]. Full list: [${player.purchasedItems.join(', ')}]`); didReturnFromBM = true; } }
                if (returnedIskStr) { const returnedIsk = parseInt(returnedIskStr, 10); if (!isNaN(returnedIsk)) { isk = returnedIsk; iskEl.textContent = Math.floor(isk); console.log(`Set ISK from BM return value: ${isk}`); didReturnFromBM = true; } else { console.warn("Received invalid ISK from BM:", returnedIskStr); } }

                if (didReturnFromBM) { if (player.collectedIntelLogs.length > 0) { console.log(`Clearing ${player.collectedIntelLogs.length} potentially sold intel logs.`); player.collectedIntelLogs = []; intelLogsEl.textContent = player.collectedIntelLogs.length; } applyItemEffects(); if (newItemsAcquired.length > 0) { const itemNames = newItemsAcquired.map(id => { switch(id) { case 'cargo_expander_1': return "Cargo Expander I"; case 'mining_laser_upgrade_1': return "MLU-7 'Rockeater'"; case 'afterburner_1': return "Smuggler's AB"; case 'long_range_scanner': return "Mod Survey Scanner"; case 'intel_logger_1': return "Covert Log Scraper"; default: return "Unknown Mod"; } }).join(', '); showMessage(`Acquired from market: ${itemNames}`, 4000); } try { window.history.replaceState({}, document.title, window.location.pathname); console.log("Processed return data, URL parameters cleared."); } catch (e) { console.warn("Could not clear URL parameters:", e); } } else { applyItemEffects(); } // Apply effects even on initial load
                 console.log("DIAGNOSTIC: loadDataFromUrl finished.");
            } catch(e) {
                console.error("DIAGNOSTIC: Error in loadDataFromUrl", e);
                applyItemEffects(); // Try to apply base effects even if URL loading failed
            }
        }

        // --- Main Game Loop ---
        let gameLoopCounter = 0; // DIAGNOSTIC
        function gameLoop(timestamp) {
            gameLoopCounter++; // DIAGNOSTIC
            if (gameLoopCounter < 5) { // Log only first few ticks
                 console.log(`DIAGNOSTIC: gameLoop tick #${gameLoopCounter}, timestamp: ${timestamp}, assetsLoaded: ${assetsLoaded}`);
            }

            if (!lastTime) { lastTime = timestamp; }
            const baseDeltaTime = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;
            const effectiveDeltaTime = baseDeltaTime * tidiFactor;

            try {
                handleInput(effectiveDeltaTime);
                update(effectiveDeltaTime);
                render(baseDeltaTime);
            } catch (error) {
                console.error("DIAGNOSTIC: Error caught in game loop's try/catch:", error);
                assetsLoaded = false; // Attempt to stop rendering
                if(ctx) { /* Draw error on canvas */ }
                return; // Stop requesting new frames
            }
            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if(e.key === 'Enter' && isGameOver) { keys['enter'] = true; } });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; if(e.key === 'Enter') { keys['enter'] = false; }});
        gameOverOverlayEl.addEventListener('click', resetGame);

        maxCargoEl.textContent = PLAYER_MAX_CARGO; iskEl.textContent = isk; intelLogsEl.textContent = '0';

        blackMarketButtonEl.addEventListener('click', () => { try { if (isDocked && isk >= BLACK_MARKET_ENTRY_ISK) { let url = `${BLACK_MARKET_HTML_FILE}?isk=${Math.floor(isk)}`; if (player.collectedIntelLogs.length > 0) { url += `&logs=${player.collectedIntelLogs.length}`; console.log(`Sending ${player.collectedIntelLogs.length} logs to market.`); } else { console.log("No intel logs to send to market."); } console.log(`Navigating to Black Market: ${url}`); window.location.href = url; } else if (!isDocked) { showMessage("Must be docked at Jita 4-4 to access market.", 2000); } else { showMessage(`Insufficient ISK. Need ${BLACK_MARKET_ENTRY_ISK.toLocaleString()} ISK to enter.`, 2000); } } catch(e){console.error("DIAGNOSTIC: Error in BM Button Click", e)} });

        // --- Start the game ---
        console.log("DIAGNOSTIC: Initializing game...");
        loadAssets(); // This function now sets assetsLoaded = true on success
        loadDataFromUrl();
        // *** DIAGNOSTIC: Check if assetsLoaded before starting loop ***
        if (assetsLoaded) {
            console.log("DIAGNOSTIC: Assets loaded successfully, requesting game loop.");
            requestAnimationFrame(gameLoop);
        } else {
             console.error("DIAGNOSTIC: Assets NOT loaded after loadAssets call, game loop NOT started. Check for errors above.");
             // Optionally display a persistent error message on the UI
             if(ctx) { ctx.fillStyle='red'; ctx.fillRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT); ctx.fillStyle='white'; ctx.font='18px monospace'; ctx.textAlign='center'; ctx.fillText("Asset Loading Failed. Check Console (F12).", SCREEN_WIDTH/2, SCREEN_HEIGHT/2); }
        }
        console.log("DIAGNOSTIC: End of script execution.");

    </script>
</body>
</html>
